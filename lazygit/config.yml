customCommands:
  - key: <c-a>
    description: Lazycommit
    command: |
      (
        saved_stty=$(stty -g 2>/dev/null || true)
        
        cleanup() {
          # Restaurar el estado de la terminal
          [ -n "$saved_stty" ] && stty "$saved_stty" 2>/dev/null || true
          # Limpiar cualquier mensaje residual
          tput clear 2>/dev/null || true
          tput reset 2>/dev/null || true
        }
        
        trap cleanup EXIT INT TERM
        
        aichat "You are a Git commit message expert, specializing in detailed and meaningful commit messages.

          TASK: Generate 5 commit messages for the following changes, considering multiple files may have been modified.

          CURRENT CHANGES:
          \`\`\`diff
          $(git diff --cached)
          \`\`\`

          RECENT COMMITS:
          \`\`\`
          $(git log -n 5 --pretty=format:'%h %s')
          \`\`\`

          REQUIREMENTS:

          1. Conventional Commits Format:
             <type>: <short summary>
             
             [optional body]
             [optional footer(s)]

          2. Types:
             - feat: new feature
             - fix: bug fix
             - docs: documentation only
             - style: formatting, missing semi colons, etc
             - refactor: code change that neither fixes a bug nor adds a feature
             - test: adding missing tests
             - chore: updating build tasks, package manager configs, etc
             - perf: performance improvements
             - ci: CI related changes

          3. Best Practices:
             - Consider ALL modified files and their relationships
             - Group related changes under a single commit if they serve one purpose
             - Break unrelated changes into separate commit suggestions
             - Focus on the overall impact rather than individual file changes
             - Keep the scope in mind (e.g., 'feat(api): ...' or 'fix(ui): ...')
             - Include breaking changes warnings when needed: BREAKING CHANGE:
             - Reference issues if applicable: 'fixes #123' or 'relates to #456'

          4. Message Structure:
             - Subject line: max 50 chars, imperative mood
             - Body: wrapped at 72 chars, explains WHY and WHAT
             - Footer: reference issues, breaking changes

          Please analyze the complete diff across all modified files and suggest 5 comprehensive commit messages that:
          - Capture the full scope of changes
          - Group related modifications
          - Follow industry best practices
          - Are clear and meaningful for future reference
          - Consider the relationships between changed components

          OUTPUT FORMAT:
          5 commit messages, each on a new line, no numbering or bullets" \
            | fzf --height 40% --border --ansi --preview "echo {}" --preview-window=up:wrap \
            | sed -E 's/^[0-9]+\.\s*//' \
            | (read -r message && git commit --no-verify -m "$message")
      )
    context: files
    subprocess: true
